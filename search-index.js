var searchIndex = {};
searchIndex["ar"] = {"doc":"A library for encoding/decoding Unix archive files.","items":[[3,"Header","ar","Representation of an archive entry header.",null,null],[3,"Archive","","A structure for reading archives.",null,null],[3,"Entry","","Representation of an archive entry.",null,null],[3,"Symbols","","An iterator over the symbols in the symbol table of an archive.",null,null],[3,"Builder","","A structure for building archives.",null,null],[4,"Variant","","Variants of the Unix archive format.",null,null],[13,"Common","","Used by Debian package files; allows only short filenames.",0,null],[13,"BSD","","Used by BSD `ar` (and OS X); backwards-compatible with common variant.",0,null],[13,"GNU","","Used by GNU `ar` (and Windows); incompatible with common variant.",0,null],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"variant"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"variant"}],"output":{"name":"bool"}}],[11,"new","","Creates a header with the given file identifier and size, and all other fields set to zero.",1,{"inputs":[{"name":"vec"},{"name":"u64"}],"output":{"name":"header"}}],[11,"from_metadata","","Creates a header with the given file identifier and all other fields set from the given filesystem metadata.",1,{"inputs":[{"name":"vec"},{"name":"metadata"}],"output":{"name":"header"}}],[11,"identifier","","Returns the file identifier.",1,null],[11,"set_identifier","","Sets the file identifier.",1,{"inputs":[{"name":"self"},{"name":"vec"}],"output":null}],[11,"mtime","","Returns the last modification time in Unix time format.",1,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"set_mtime","","Sets the last modification time in Unix time format.",1,{"inputs":[{"name":"self"},{"name":"u64"}],"output":null}],[11,"uid","","Returns the value of the owner's user ID field.",1,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"set_uid","","Sets the value of the owner's user ID field.",1,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"gid","","Returns the value of the group's user ID field.",1,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"set_gid","","Returns the value of the group's user ID field.",1,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"mode","","Returns the mode bits for this file.",1,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"set_mode","","Sets the mode bits for this file.",1,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"size","","Returns the length of the file, in bytes.",1,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"set_size","","Sets the length of the file, in bytes.",1,{"inputs":[{"name":"self"},{"name":"u64"}],"output":null}],[11,"new","","Create a new archive reader with the underlying reader object as the source of all data read.",2,{"inputs":[{"name":"r"}],"output":{"name":"archive"}}],[11,"variant","","Returns which format variant this archive appears to be so far.",2,{"inputs":[{"name":"self"}],"output":{"name":"variant"}}],[11,"into_inner","","Unwrap this archive reader, returning the underlying reader object.",2,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"next_entry","","Reads the next entry from the archive, or returns None if there are no more.",2,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"count_entries","","Scans the archive and returns the total number of entries in the archive (not counting special entries, such as the GNU archive name table or symbol table, that are not returned by `next_entry()`).",2,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"jump_to_entry","","Scans the archive and jumps to the entry at the given index.  Returns an error if the index is not less than the result of `count_entries()`.",2,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"result"}}],[11,"symbols","","Scans the archive and returns an iterator over the symbols in the archive's symbol table.  If the archive doesn't have a symbol table, this method will still succeed, but the iterator won't produce any values.",2,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"header","","Returns the header for this archive entry.",3,{"inputs":[{"name":"self"}],"output":{"name":"header"}}],[11,"read","","",3,null],[11,"seek","","",3,{"inputs":[{"name":"self"},{"name":"seekfrom"}],"output":{"name":"result"}}],[11,"drop","","",3,{"inputs":[{"name":"self"}],"output":null}],[11,"next","","",4,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",4,null],[11,"new","","Create a new archive builder with the underlying writer object as the destination of all data written.",5,{"inputs":[{"name":"w"}],"output":{"name":"builder"}}],[11,"into_inner","","Unwrap this archive builder, returning the underlying writer object.",5,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"append","","Adds a new entry to this archive.",5,{"inputs":[{"name":"self"},{"name":"header"},{"name":"r"}],"output":{"name":"result"}}],[11,"append_path","","Adds a file on the local filesystem to this archive, using the file name as its identifier.",5,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"name":"result"}}],[11,"append_file","","Adds a file to this archive, with the given name as its identifier.",5,null]],"paths":[[4,"Variant"],[3,"Header"],[3,"Archive"],[3,"Entry"],[3,"Symbols"],[3,"Builder"]]};
initSearch(searchIndex);
